import Tour from "../Models/Tour.js"
import { Comment, } from "../Models/Comment.js";
export const createComment = async (req, res) => {
    const tourId = req.params.tourId;
    const newComment = new Comment({
        ...req.body,
        
    });
    try {
        const savedComment = await newComment.save();

        await Tour.findByIdAndUpdate(tourId, {
            $push: { reviews: savedComment._id },
        });

        res.status(201).json({ success: true, message: 'Comment added', data: savedComment });
    } catch (error) {
        res.status(500).json({ success: false, message: 'Failed to add comment', error });
    }
}

export const createReply = async (req, res) => {
    const { commentId, parentReplyId } = req.params; // parentReplyId is optional
    const { content, user } = req.body;

    try {
        // Fetch the comment by ID
        const comment = await Comment.findById(commentId);
        if (!comment) {
            return res.status(404).json({ success: false, message: "Comment not found" });
        }

        let replyingToUser = null;

        // Recursive function to find the parent reply and add a nested reply
        const addNestedReply = (replies, parentReplyId, newReply) => {
            for (let reply of replies) {
                if (reply._id && reply._id.toString() === parentReplyId) {
                    replyingToUser = reply.user; // Capture the user being replied to
                    reply.replies.push(newReply); // Add the new reply to this reply's replies
                    return true; // Stop searching after adding
                }

                // Recursively search for the parent reply in nested replies
                if (reply.replies && reply.replies.length > 0) {
                    const added = addNestedReply(reply.replies, parentReplyId, newReply);
                    if (added) return true; // Stop searching if reply is added
                }
            }
            return false; // Parent reply not found
        };

        // Construct the new reply object
        const newReply = {
            user,
            content,
            replyingTo: null, // Will be set based on `parentReplyId` or main comment
            originalCommentId: commentId,
            replies: [], // Initialize as an empty array
        };

        // If replying to a nested reply, set `replyingTo` and search for the parent reply
        if (parentReplyId) {
            const replyAdded = addNestedReply(comment.replies, parentReplyId, newReply);
            if (!replyAdded) {
                return res.status(404).json({ success: false, message: "Parent reply not found" });
            }
            newReply.replyingTo = replyingToUser; // Set the "replyingTo" field
        } else {
            // If it's a direct reply to the main comment, set "replyingTo" as the comment's user
            replyingToUser = comment.user;
            newReply.replyingTo = replyingToUser; // Set the "replyingTo" field
            comment.replies.push(newReply);
        }

        // Save the comment (and all replies) to generate ObjectId for the replies
        const savedComment = await comment.save();  // Save the comment, which will also save replies

        // The new reply will now have its ObjectId generated by MongoDB
        const replyWithId = savedComment.replies.find(reply => reply.content === content); // Find the reply with the same content

        res.status(201).json({
            success: true,
            message: "Reply added successfully",
            data: { 
                reply: replyWithId,  // Return the reply object with its generated _id
                comment: savedComment // Return the updated comment
            },
        });

    } catch (error) {
        console.error("Error adding reply:", error); // Log error for debugging
        res.status(500).json({
            success: false,
            message: "Failed to add reply",
            error: error.message || error,
        });
    }
};



